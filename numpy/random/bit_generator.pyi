from threading import Lock
from typing import Literal, Optional

from numpy import DtypeLike, ndarray
from numpy.typing import ArrayLike, _ShapeLike

class SeedlessSeedSequence:
    def generate_state(
        self, n_words: int, dtype: DtypeLike = ...
    ) -> ndarray: ...
    def spawn(self, n_children: int) -> List[SeedlessSeedSequence]: ...

class SeedSequence:
    def __init__(
        self,
        entropy: Optional[int, Sequence[int]] = ...,
        *,
        spawn_key: Tuple[int, ...] = ...
    ) -> None: ...
    def __repr__(self) -> str: ...
    @property
    def state(
        self,
    ) -> Dict[str, Union[None, Sequence[int], int, Tuple[int, ...]]]: ...
    def generate_state(
        self, n_words: int, dtype: DtypeLike = np.uint32
    ) -> ndarray: ...
    def spawn(self, n_children: int) -> List[SeedSequence]: ...

class BitGenerator:
    lock: Lock
    def __init__(self, seed=Optional[int, ArrayLike, SeedSequence]) -> None: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, state: Dict[str, Any]) -> None: ...
    def __reduce__(
        self,
    ) -> Tuple[
        Callable[[str], BitGenerator], Tuple[str], Tuple[Dict[str, Any]]
    ]: ...
    @property
    def state(self) -> Dict[str, Any]: ...
    @state.setter
    def state(self, value: Dict[str, Any]): ...
    @overload
    def random_raw(
        self, size: None = ..., output: Literal[True] = ...
    ) -> int: ...
    @overload
    def random_raw(
        self, size=_ShapeLike, output: Literal[True] = ...
    ) -> ndarray: ...
    @overload
    def random_raw(
        self, size=Optional[_ShapeLike], output: Literal[False] = ...
    ) -> None: ...
    def _benchmark(self, cnt: int, method: str = ...) -> None: ...
    # TODO: These are untyped
    @property
    def ctypes(self) -> Any: ...
    @property
    def cffi(self) -> Any: ...
