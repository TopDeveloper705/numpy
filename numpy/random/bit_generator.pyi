import abc
from threading import Lock
from typing import (Any, Callable, Dict, List, Literal, NamedTuple, Optional,
                    Sequence, Tuple, Union, overload)

from numpy import dtype, ndarray, uint32, uint64
from numpy.typing import DTypeLike, _ArrayLikeInt_co, _ShapeLike

class _Interface(NamedTuple):
    state_address: Any
    state: Any
    next_uint64: Any
    next_uint32: Any
    next_double: Any
    bit_generator: Any

class ISeedSequence(abc.ABC):
    @abc.abstractmethod
    def generate_state(
        self, n_words: int, dtype: DTypeLike = ...
    ) -> ndarray[Any, Any]: ...

class ISpawnableSeedSequence(ISeedSequence):
    @abc.abstractmethod
    def spawn(self, n_children: int) -> List[ISpawnableSeedSequence]: ...

class SeedlessSeedSequence(ISeedSequence):
    def generate_state(
        self, n_words: int, dtype: DTypeLike = ...
    ) -> ndarray[Any, Any]: ...
    def spawn(self, n_children: int) -> List[SeedlessSeedSequence]: ...

class SeedSequence(ISpawnableSeedSequence):
    entropy: Union[None, int, Sequence[int]]
    spawn_key: Tuple[int, ...]
    pool_size: int
    n_children_spawned: int
    pool: ndarray[Any, dtype[uint32]]
    def __init__(
        self,
        entropy: Union[None, int, Sequence[int]] = ...,
        *,
        spawn_key: Tuple[int, ...] = ...,
        pool_size: int = ...,
        n_children_spawned: int = ...,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @property
    def state(
        self,
    ) -> Dict[str, Union[None, Sequence[int], int, Tuple[int, ...]]]: ...
    def generate_state(
        self, n_words: int, dtype: DTypeLike = ...
    ) -> ndarray[Any, Any]: ...
    def spawn(self, n_children: int) -> List[SeedSequence]: ...

class BitGenerator:
    lock: Lock
    def __init__(
        self, seed: Union[None, int, _ArrayLikeInt_co, SeedSequence] = ...
    ) -> None: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, state: Dict[str, Any]) -> None: ...
    def __reduce__(
        self,
    ) -> Tuple[
        Callable[[str], BitGenerator], Tuple[str], Tuple[Dict[str, Any]]
    ]: ...
    @property
    def state(self) -> Dict[str, Any]: ...
    @state.setter
    def state(self, value: Dict[str, Any]): ...
    @overload
    def random_raw(
        self, size: None = ..., output: Literal[True] = ...
    ) -> int: ...
    @overload
    def random_raw(
        self, size: _ShapeLike = ..., output: Literal[True] = ...
    ) -> ndarray[Any, dtype[uint64]]: ...
    @overload
    def random_raw(
        self, size: Optional[_ShapeLike] = ..., output: Literal[False] = ...
    ) -> None: ...
    def _benchmark(self, cnt: int, method: str = ...) -> None: ...
    @property
    def ctypes(self) -> _Interface: ...
    @property
    def cffi(self) -> _Interface: ...
